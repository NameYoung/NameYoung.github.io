<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Globalization Date Transfer (中) - java.time.ZonedDateTime</title>
    <link href="/2021/06/22/global-date-transfer-2/"/>
    <url>/2021/06/22/global-date-transfer-2/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>Date transfer in globalization web app</p>          </div><a id="more"></a><h1 id="Date-vs-ZonedDateTime"><a href="#Date-vs-ZonedDateTime" class="headerlink" title="Date vs ZonedDateTime"></a>Date vs ZonedDateTime</h1><h3 id="Date-缺点"><a href="#Date-缺点" class="headerlink" title="Date 缺点"></a>Date 缺点</h3><p>详情可以看这篇大佬的<a href="https://codeblog.jonskeet.uk/2017/04/23/all-about-java-util-date/">吐槽</a><br>实际开发来讲，比较棘手的问题如下：</p><ul><li>明明是个瞬时时间点，但是却可以修改，所以使用过程中存在隐患（如某个方法不小心修改了数据）(非线程安全)</li><li>方法有歧义，开发易挖坑（如toString()方法默认转换为本地时区时间，但实际其并没有时区属性）</li><li>格式转换比较麻烦（如输出ISO8601格式）</li><li>日期运算比较麻烦（如计算两个日期相隔天数）</li></ul><h3 id="java-time-优点"><a href="#java-time-优点" class="headerlink" title="java.time.* 优点"></a>java.time.* 优点</h3><ul><li>包含时区，方便时区转换</li><li>丰富的计算方法，方便时间比较计算</li><li>线程安全（immutable)</li></ul><div class="note note-info">            <p><a href="https://www.joda.org/joda-time/">JodaTime</a>也强烈建议开发者使用java.time.*</p>          </div><h1 id="Spring-Date参数转换"><a href="#Spring-Date参数转换" class="headerlink" title="Spring Date参数转换"></a>Spring Date参数转换</h1><blockquote><p>Spring如何处理请求/响应中ISO8601格式的日期？</p></blockquote><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h3><p>对于@<em>RequestParam</em>声明的参数，可使用@<em>DateTimeFormat</em>进行解析。</p><h3 id="RequestBody-amp-amp-ResponseBody"><a href="#RequestBody-amp-amp-ResponseBody" class="headerlink" title="RequestBody &amp;&amp; ResponseBody"></a>RequestBody &amp;&amp; ResponseBody</h3><p>对于 Request/Response Body 数据的解析与格式化，可使用<strong>Jackson</strong>进行处理，即使用注解@<em>JsonFormat</em>。</p><div class="note note-info">            <p>Spring 中Jackson解析的核心类为<strong>MappingJackson2HttpMessageConverter</strong></p>          </div><h1 id="Mybatis-ZonedDateTime"><a href="#Mybatis-ZonedDateTime" class="headerlink" title="Mybatis ZonedDateTime"></a>Mybatis ZonedDateTime</h1><blockquote><p>上一篇已经介绍的Mybatis对Date的处理，本篇介绍下Mybatis对ZonedDateTime处理方法</p></blockquote><h3 id="ZonedDateTimeTypeHandler"><a href="#ZonedDateTimeTypeHandler" class="headerlink" title="ZonedDateTimeTypeHandler"></a>ZonedDateTimeTypeHandler</h3><p>同<strong>java.util.Date</strong>装换方式类似，将ZonedDateTime装换为ServerSessionTimeZone时区的Timestamp(Date)</p><h1 id="Mysql-Timestamp-与-DateTime"><a href="#Mysql-Timestamp-与-DateTime" class="headerlink" title="Mysql Timestamp 与 DateTime"></a>Mysql Timestamp 与 DateTime</h1><p>Timestamp与DateTime Mybatis会一视同仁，都会转为java.sql.Timestamp(Date)</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h3 id="Mysql-global-session-07-00-amp-amp-server-timezone-08-00"><a href="#Mysql-global-session-07-00-amp-amp-server-timezone-08-00" class="headerlink" title="Mysql global session(+07:00) &amp;&amp; server timezone +08:00"></a>Mysql global session(+07:00) &amp;&amp; server timezone +08:00</h3><table><thead><tr><th align="center">数据库字段类型</th><th align="center">request参数值</th><th align="center">server转换后的ZonedDateTime</th><th align="center">生成的sql value</th><th align="center">最终存储值</th></tr></thead><tbody><tr><td align="center">Timestamp</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T15:00:00+00:00</td></tr><tr><td align="center">Datetime</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T22:00:00+08:00</td></tr></tbody></table><h3 id="Mysql-global-session-07-00-amp-amp-server-timezone-08-00-amp-amp-connectionTimeZone-UTC-amp-forceConnectionTimeZoneToSession-true"><a href="#Mysql-global-session-07-00-amp-amp-server-timezone-08-00-amp-amp-connectionTimeZone-UTC-amp-forceConnectionTimeZoneToSession-true" class="headerlink" title="Mysql global session(+07:00) &amp;&amp; server timezone +08:00 &amp;&amp; connectionTimeZone=UTC&amp;forceConnectionTimeZoneToSession=true"></a>Mysql global session(+07:00) &amp;&amp; server timezone +08:00 &amp;&amp; connectionTimeZone=UTC&amp;forceConnectionTimeZoneToSession=true</h3><table><thead><tr><th align="center">数据库字段类型</th><th align="center">request参数值</th><th align="center">server转换后的ZonedDateTime</th><th align="center">生成的sql value</th><th align="center">最终存储值</th></tr></thead><tbody><tr><td align="center">Timestamp</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td></tr><tr><td align="center">Datetime</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>实际使用的建议，同Date一样，务必保证Server 与 MySQL的时区一致（都设置为UTC），避免潜在的数据转换问题。<br>同时也要设置<strong>connectionTimeZone=UTC &amp;&amp; forceConnectionTimeZoneToSession=true</strong></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Globalization</tag>
      
      <tag>Java</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Globalization Date Transfer (上) - java.util.Date</title>
    <link href="/2021/05/22/global-date-transfer/"/>
    <url>/2021/05/22/global-date-transfer/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>Date transfer in globalization web app</p>          </div><a id="more"></a><h1 id="关于日期与时间"><a href="#关于日期与时间" class="headerlink" title="关于日期与时间"></a>关于日期与时间</h1><blockquote><p>做国际化产品时，一定会涉及到不同国家不同时区转换问题。为保证时间一致性，后端该如何选择数据结构，如何定义API？</p></blockquote><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><ul><li>Spring</li><li>MySQL 5.7</li><li>MyBatis</li></ul><h2 id="GMT-amp-amp-UTC"><a href="#GMT-amp-amp-UTC" class="headerlink" title="GMT &amp;&amp; UTC"></a>GMT &amp;&amp; UTC</h2><p>GMT与UTC，是常听到两个时间相关的名词，可以简单的理解为UTC基于GMT的升级，UTC使用原子时钟定义时间，克服了GMT的弊端（时间流逝不均匀），所以UTC也就最终成为世界标准时间。</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%A8%99%E6%BA%96%E6%99%82%E9%96%93">参考链接-格林尼治标准时间GMT</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6">参考链接-协调世界时UTC</a></li></ol><h2 id="UNIX时间戳-amp-amp-ISO8601"><a href="#UNIX时间戳-amp-amp-ISO8601" class="headerlink" title="UNIX时间戳 &amp;&amp;     ISO8601"></a>UNIX时间戳 &amp;&amp;     ISO8601</h2><p><strong>UNIX时间戳：</strong> 是类UNIX系统中所采用的时间格式，记录的是UTC(0时区) 1970年1月1日0时0分0秒起至现在的总秒数，<br>由于一般以32位有符号整数表示，故表示范围有限，存在比较著名的<a href="https://stackoverflow.com/questions/2012589/php-mysql-year-2038-bug-what-is-it-how-to-solve-it">2038问题</a>，有兴趣的话可以一看。</p><p><strong>ISO8601：</strong> 是国际标准组织对日期表示制定的一套标准，常见的形式如：‘2021-05-30T12:00:00+08:00’，详细介绍查看该<a href="https://www.iso.org/iso-8601-date-and-time-format.html">链接</a></p><h2 id="Mysql-中的-Date"><a href="#Mysql-中的-Date" class="headerlink" title="Mysql 中的 Date"></a>Mysql 中的 Date</h2><p>MySql 中主要的时间表示方式，有Timestamp与Datetime。其实两者差别不大，从表现形式、底层存储上看基本是一个数据结构，主要的不同点如下：</p><table><thead><tr><th align="center">功能</th><th align="center">Datetime</th><th align="center">Timestamp</th></tr></thead><tbody><tr><td align="center">表示范围</td><td align="center">‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999</td><td align="center">‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’</td></tr><tr><td align="center">存储的时候是否要转为UTC(零时区)</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">字节大小</td><td align="center">5字节</td><td align="center">4字节</td></tr></tbody></table><p>所以在实际应用中，最好还是有限考虑Datetime。一方面是其表示范围广，另一方面是在实际应用中会避免掉Mysql server自动转时区问题。</p><div class="note note-primary">            <p><a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">Mysql 8.0.19开始支持日期携带分区</a></p>          </div><h2 id="Java-中的-Date"><a href="#Java-中的-Date" class="headerlink" title="Java 中的 Date"></a>Java 中的 Date</h2><div class="note note-info">            <p>Java 的时间类比较乱，如java.util.*，java.sql.*, java.time.*</p>          </div><p>尽管java 8推出了新的<em>java.time</em>，而且是推荐使用，但<em>java.util.Date</em>依然保留。目前很多框架对<em>java.time</em>的支持并不友好（如 <em>Jackson</em>）。<br>所以本系列文章会通过<em>java.util.Date</em> 与 <em>java.time.ZonedDateTime</em>演示，来指导实际应用时的选型。本篇主要以<em>java.util.Date</em>为例。</p><h1 id="Date-参数转换"><a href="#Date-参数转换" class="headerlink" title="Date 参数转换"></a>Date 参数转换</h1><p>Request 的Date参数使用ISO8601标准定义，然后利用Jackson <a href="https://www.baeldung.com/jackson-jsonformat">@JsonFormat</a>来自动将时间串参数转换为服务器时区的Date，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateDemoRequest</span> </span>&#123;<br>    <span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:MM:SSZ&quot;)</span><br>    <span class="hljs-keyword">private</span> Date date;<br><br><span class="hljs-comment">// 省略 setter getter</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Mybatis-Mysql-转换"><a href="#Mybatis-Mysql-转换" class="headerlink" title="Mybatis - Mysql 转换"></a>Mybatis - Mysql 转换</h1><div class="note note-info">            <p>Mybatis 默认使用 DateTypeHandler处理date参数，并不会做时区转换。<br>MySQL-Connector中的ClientPreparedQueryBindings会处理时区。</p>          </div><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">MySQL session timezone</a></li><li><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-datetime-types-processing.html#cj-conn-prop_connectionTimeZone">Connector connectionTimeZone&amp;forceConnectionTimeZoneToSession</a></li></ul><p><strong>简单讲：</strong><br>当table column为Timestamp类型时，Mysql 会根据session timezone是否是0时区来转换timestamp的值；<br>jdbc url properties设置connectionTimeZone时，ClientPreparedQueryBindings会将时间（Date&amp;Timestamp）转换为该时区的时间，但是并不会修改session timezone。只有同时设置forceConnectionTimeZoneToSession=true时，才会修改session timezone。</p><h4 id="connectionTimeZone配置方式"><a href="#connectionTimeZone配置方式" class="headerlink" title="connectionTimeZone配置方式"></a>connectionTimeZone配置方式</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc</span>:<span class="hljs-string">mysql://localhost:3306/test?connectionTimeZone=UTC&amp;forceConnectionTimeZoneToSession=true</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><strong>假设Server时区为+08:00</strong><br><strong>假设MySQL session timezone为+08:00</strong></p>          </div><h3 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h3><blockquote><p>不设置connectionTimeZone（默认服务器时区）与 forceConnectionTimeZoneToSession（默认MySQL session timezone）</p></blockquote><table><thead><tr><th align="center">数据库字段类型</th><th align="center">request参数值</th><th align="center">server转换后的date</th><th align="center">生成的sql value</th><th align="center">最终存储值</th></tr></thead><tbody><tr><td align="center">Timestamp</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T14:00:00+00:00(0时区)</td></tr><tr><td align="center">Datetime</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T22:00:00+08:00</td></tr></tbody></table><h3 id="只设置connectionTimeZone-UTC"><a href="#只设置connectionTimeZone-UTC" class="headerlink" title="只设置connectionTimeZone=UTC"></a>只设置connectionTimeZone=UTC</h3><table><thead><tr><th align="center">数据库字段类型</th><th align="center">request参数值</th><th align="center">server转换后的date</th><th align="center">生成的sql value</th><th align="center">最终存储值</th></tr></thead><tbody><tr><td align="center">Timestamp</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T06:00:00+00:00(0时区)</td></tr><tr><td align="center">Datetime</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td></tr></tbody></table><h3 id="设置connectionTimeZone-UTC-amp-amp-forceConnectionTimeZoneToSession-true"><a href="#设置connectionTimeZone-UTC-amp-amp-forceConnectionTimeZoneToSession-true" class="headerlink" title="设置connectionTimeZone=UTC &amp;&amp; forceConnectionTimeZoneToSession=true"></a>设置connectionTimeZone=UTC &amp;&amp; forceConnectionTimeZoneToSession=true</h3><table><thead><tr><th align="center">数据库字段类型</th><th align="center">request参数值</th><th align="center">server转换后的date</th><th align="center">生成的sql value</th><th align="center">最终存储值</th></tr></thead><tbody><tr><td align="center">Timestamp</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00(0时区)</td></tr><tr><td align="center">Datetime</td><td align="center">2021-05-30T21:00:00+07:00</td><td align="center">2021-05-30T22:00:00+08:00</td><td align="center">2021-05-30T14:00:00+00:00</td><td align="center">2021-05-30T14:00:00+00:00</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>  由以上各类情况可以判断，当设置<strong>connectionTimeZone=UTC &amp;&amp; forceConnectionTimeZoneToSession=true</strong>，Timestamp与Datetime 数据是一致的（都是0时区），所以不论是数据查询还是数据导出都会比较方便，所以建议设置connectionTimeZone=UTC&amp;forceConnectionTimeZoneToSession=true。</p><p>  若不设置，则务必保证Server 与 MySQL的时区一致（都设置为UTC），避免潜在的数据转换问题。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Globalization</tag>
      
      <tag>Java</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot DBUnit</title>
    <link href="/2021/03/07/spring-db-unit/"/>
    <url>/2021/03/07/spring-db-unit/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>如何在Spring项目中使用DBUnit?</p>          </div><a id="more"></a><blockquote><p>项目中一直打算引入数据库单测，抽空研究了一下DBUnit. 并根据项目做了些简单修改，本文将以 <strong>MyBatis+MySQL</strong> 为例创建 DBunit Test</p></blockquote><h1 id="DBUnit-简述"><a href="#DBUnit-简述" class="headerlink" title="DBUnit 简述"></a>DBUnit 简述</h1><blockquote><p><a href="http://dbunit.sourceforge.net/">DBUnit项目地址</a></p></blockquote><div class="note note-primary">            <p>DBUnit 是一个数据库单测工具，基于JUnit.<br>目的是执行单测试时保证数据库数据已知以及数据可重复利用</p>          </div><h1 id="Spring-DBunit"><a href="#Spring-DBunit" class="headerlink" title="Spring DBunit"></a>Spring DBunit</h1><blockquote><p><a href="https://springtestdbunit.github.io/spring-test-dbunit/sample.html">项目地址</a></p></blockquote><div class="note note-primary">            <p>Spring 项目的维护者 @philwebb 创建了一个开源项目spring-test-dbunit 方便DBUnit 在Spring‘套餐’中使用。PS: 由于他本人很忙，此项目已经废弃。</p>          </div><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><blockquote><p>以gradle为例</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>implementation <span class="hljs-string">&#x27;org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.4&#x27;</span><br><span class="hljs-comment">// 用flyway来管理数据库脚本</span><br>implementation <span class="hljs-string">&#x27;org.flywaydb:flyway-core&#x27;</span><br><br>runtimeOnly <span class="hljs-string">&#x27;mysql:mysql-connector-java&#x27;</span><br><br>    <span class="hljs-comment">// 核心包</span><br>testImplementation <span class="hljs-string">&#x27;com.github.springtestdbunit:spring-test-dbunit:1.2.0&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;org.dbunit:dbunit:2.7.0&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;com.h2database:h2&#x27;</span><br><span class="hljs-comment">// 常规包</span><br>testImplementation <span class="hljs-string">&#x27;org.mybatis.spring.boot:mybatis-spring-boot-starter-test:2.1.4&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span><br>testImplementation <span class="hljs-string">&#x27;junit:junit&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数据库脚本"><a href="#数据库脚本" class="headerlink" title="数据库脚本"></a>数据库脚本</h2><p><strong>src/main/resources/db/migration/V1__init_user.sql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 若类路径有flyway包，则spring boot会自动加载<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> <span class="hljs-keyword">user</span><br>(<br>    id         <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span>,<br>    last_name  <span class="hljs-type">char</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    first_name <span class="hljs-type">char</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><h2 id="创建基本类"><a href="#创建基本类" class="headerlink" title="创建基本类"></a>创建基本类</h2><p><strong>UserMapper.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>User.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-keyword">private</span> String firstName;<br><br>    <span class="hljs-comment">// setter &amp;&amp; getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UserMapper.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.spring.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.spring.model.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;last_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;first_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        select *<br>        from<br>            `user`<br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><h3 id="测试配置文件"><a href="#测试配置文件" class="headerlink" title="测试配置文件"></a>测试配置文件</h3><blockquote><p>覆盖默认配置，本例使用h2内存数据库，所以达到每次执行测试都有一个新库的效果，不会影响真实数据库环境</p></blockquote><p><strong>test/java/resourcesapplication.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:h2:mem:test</span><br><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">org.h2.Driver</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><br><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/*.xml</span><br></code></pre></td></tr></table></figure><h3 id="DBUnit-dataset文件"><a href="#DBUnit-dataset文件" class="headerlink" title="DBUnit dataset文件"></a>DBUnit dataset文件</h3><blockquote><p>使用DBUnit自身的CSV DataSet, 也可使用xml等文件配置数据集</p></blockquote><p><strong>test/java/resources/csv/table-ordering.txt</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">user<br></code></pre></td></tr></table></figure><p><strong>test/java/resources/csv/user.csv</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">id,first_name,last_name<br>3,wukong,sun<br>4,seng,tang<br></code></pre></td></tr></table></figure><h3 id="DBUnit-配置"><a href="#DBUnit-配置" class="headerlink" title="DBUnit 配置"></a>DBUnit 配置</h3><blockquote><p>使用CSV文件时，需要做一些自定义配置。使用XML可以参考spring-test-dbunit的DEMO</p></blockquote><p><strong>CsvLoader.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CsvLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDataSetLoader</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> IDataSet <span class="hljs-title">createDataSet</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvURLDataSet(resource.getURL());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>CustomTestConfiguration.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TestConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTestConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSetLoader <span class="hljs-title">dataSetLoader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CsvLoader();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><p><strong>DbunitTest.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = CustomTestConfiguration.class)</span><br><span class="hljs-meta">@MybatisTest</span><br><span class="hljs-meta">@DbUnitConfiguration(databaseConnection = &quot;dataSource&quot;, dataSetLoader = CsvLoader.class)</span><br><span class="hljs-meta">@TestExecutionListeners(&#123;DependencyInjectionTestExecutionListener.class,</span><br><span class="hljs-meta">                         DbUnitTestExecutionListener.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbunitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DatabaseSetup(&quot;classpath:csv/user.csv&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectOne</span><span class="hljs-params">()</span> </span>&#123;<br>        User userA = userMapper.selectById(<span class="hljs-number">3L</span>);<br>        assertEquals(<span class="hljs-string">&quot;wukong&quot;</span>, userA.getFirstName());<br><br>        User userB = userMapper.selectById(<span class="hljs-number">4L</span>);<br>        assertEquals(<span class="hljs-string">&quot;tang&quot;</span>, userB.getLastName());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="其他组件集成"><a href="#其他组件集成" class="headerlink" title="其他组件集成"></a>其他组件集成</h1><h2 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h2><p>Spring JPA 配置思路基本一致</p><h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><blockquote><p>与MyBatis一致</p></blockquote><div class="note note-success">            <p>引入 com.baomidou:mybatis-plus-boot-starter:{version}<br>使用 <strong>@MybatisPlusTest</strong> 替换 <strong>@MybatisTest</strong></p>          </div><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>终于可以免于手动测试了…… 后续抽时间讲一下原理</p>]]></content>
    
    
    <categories>
      
      <category>UnitTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
      <tag>DBUnit</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>UnitTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Get Key</title>
    <link href="/2021/01/24/redis-str-get/"/>
    <url>/2021/01/24/redis-str-get/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>为什么 GET [key] 复杂度为 O(1) ?</p>          </div><a id="more"></a><h1 id="键值对存储结构"><a href="#键值对存储结构" class="headerlink" title="键值对存储结构"></a>键值对存储结构</h1><blockquote><p>Redis 所有键值对存储在一个全局字典表中，利用key来快速查找匹配到对应的键值对，时间复杂度O(1)<br>可以类比 <strong>Java HashMap</strong> </p></blockquote><p><img src="/images/redis-dic.png" alt="pic 1: redis 字典结构"></p><div class="note note-success">            <p>补充：</p><ul><li>ht[0]、ht[1] 是为rehash准备的</li><li>字段具体结构会在后续文章展开</li></ul>          </div><h1 id="Key查找方法"><a href="#Key查找方法" class="headerlink" title="Key查找方法"></a>Key查找方法</h1><blockquote><p>源文件 src/dict.c#dicFind</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">dictEntry *<span class="hljs-title">dictFind</span><span class="hljs-params">(dict *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// *d 即为键值对字典对象指针</span><br>    dictEntry *he;<br>    <span class="hljs-keyword">uint64_t</span> h, idx, table;<br><br>    <span class="hljs-keyword">if</span> (dictSize(d) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);<br><br>    <span class="hljs-comment">// 获得key的hash值</span><br>    h = dictHashKey(d, key);<br>    <span class="hljs-comment">// table即为上图中的 ht数组（共有两个元素）</span><br>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;<br>    <span class="hljs-comment">// 计算key的index</span><br>        idx = h &amp; d-&gt;ht[table].sizemask;<br>        <span class="hljs-comment">// 获取到index对应链表的头指针</span><br>        he = d-&gt;ht[table].table[idx];<br>        <span class="hljs-keyword">while</span>(he) &#123;<br>        <span class="hljs-comment">// 逐个判断是否相等</span><br>            <span class="hljs-keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))<br>                <span class="hljs-keyword">return</span> he;<br>            he = he-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 若没有正在镜像 rehash, 则直接结束 即rehash时两个table都要进行扫描</span><br>        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由源代码可知, 查找key（dictEntry）只需两步</p><ol><li>计算hash值并计算索引</li><li>链表上逐个匹配</li></ol><h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><pre><code class="mermaid" >flowchart TB    getGenericCommand-->lookupKeyReadOrReplysubgraph t_string.c    getCommand-->getGenericCommand    end    subgraph db.c    lookupKeyReadOrReply-->lookupKeyReadWithFlags    lookupKeyReadWithFlags-->lookupKey    lookupKey-->dictFind    end</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><div class="note note-info">            <p>由以上可知，Redis GET Key 并不是严格意义上的 O(1), 实际上是O(1+M) M即链表上查找所经过的长度。但是为什么文档上写O(1)呢？这是因为Redis rehash保证了每个桶（dictEntry 链表）持有尽可能少的元素，所以时间复杂度近似O(1)。</p>          </div><p>下一篇，继续从源码入手研究rehash策略。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 开篇大吉</title>
    <link href="/2021/01/09/first-blog/"/>
    <url>/2021/01/09/first-blog/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？</p><footer><strong>孟子 《论语》</strong></footer></blockquote><a id="more"></a><p>花了半天时间，建了下博客。一直期望找个清净之地，记录一下所思所想，挑来挑去，还是借GitHub宝地一用吧。</p><p>写代码的时候，发现了GitHub已将master更改为main，结合地球另一边的“大闹天宫”，再看看当下疫情，过去的2020真是风云变幻、大开眼界之年。经济全球化的大趋势难以逆转，类似川普等保守势力的上台只能说是回光返照、“短期反弹”，任何国家，甚至是任何个人也难以独善其身，合作才能共赢啊。虽说我们抗疫取得阶段胜利，但是防控、发展等各方面的压力都非常大，原来这就是“百年未有之大变局”。新的一年，期望疫情早早结束，打工人能<strong>少加班、多挣钱</strong>。</p><p>2021年，也给自己做一些新的要求，期望以此为始，<strong>持续学习</strong>，定期输出：</p><ul><li>多读书多看报</li><li>技术类文章 1 篇/月</li><li>其他类文章 随缘更新</li></ul><p>对于技术而言，还是要戒骄戒躁，一步步啃难点。对于常用的中间件，有机会还是要多读读源码，既要懂得原理，也要学会拿来即用。急于求成是不可取的，要以实战项目为中心，<strong>“点-线-面”</strong>的搭建自己的知识体系，定期的总结归纳是必须的。<br>每日三省做不到没关系，每周一省就可以了：</p><ul><li>每周少摸了几天鱼</li><li>每周少加了几天班</li><li>每周遇到了哪些坑</li><li>每周多学了几个知识</li><li>每周写了多少有效代码</li></ul><blockquote><p>2021，冲冲冲！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
